{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"htcollector Gather incoming temperature and humidity updates from a small swarm of Shellyht devices. Intro Shelly HT devices can be configured to send their measurements to a configurable server. The server is called using a simple HTTP GET request like http://mymachine:8083/sensorlog?hum=24&temp=42.38&id=shellyht-1234FA where the part http://mymachine:8083/sensorlog is something you configure in the sensor itself. htcollector is a solution that intercepts these requests and logs the data in a database. It also provides means to associate meaningful labels with the station-ids and generate html, json or a png image with the latest measurements. Installation and use 'htcollector` is a Python package that can be used to implement your own server that intercepts messages from Shelly HT devices or you can use the default server implementation that is part of the package. If you are already working with Docker things are even simpler as the two necessary images are provided as part of this project and available on the GitHub Container Registry Easy installation using Docker htcollector is provided as an easy to use Docker solution too: You can simply download just a file with environment variables and a docker compose file and start that up with docker compose (watch the long curl lines!): mkdir htcollector-docker cd htcollector-docker mkdir docker cd docker curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/.env > .env curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/docker-compose.yml > docker-compose.yml docker compose -f docker-compose.yml up -d This will download two images and start them as two containers: one running a MariaDB server and one running the htcollector. By default the htcollector is configured to listen on port 8083 for incoming measurements from the devices, but this can be changed of course (or you can change the configuration of your Shelly HT devices). When measurements start getting logged, you can go to the same webserver to get an html page with the last measurements: http://mymachine:8083/html An even nicer looking example is available on http://mymachine:8083/all These pages refer to two additional urls: static/css/stylesheet.css and static/js/layout.js , which are served by the same server. You can also associate a meaningful label with any station, simply go to: http://mymachine:8083/names and click on the device you want to change the label of. Note Tested with Docker version 20.10.12, build 20.10.12-0ubuntu2~20.04.1 / Docker Compose version v2.6.0 Installation as a library You can of course build your own solution on top of the htcollector module but that takes a few steps. Installing the htcollector package from Pypi is simple enough but it also depends on the MariaDB connector. Install mariadb connector for Python The mariadb python module is not pure Python and depends on libmariadb , so setup is less straight forward than you would hope: wget https://downloads.mariadb.com/MariaDB/mariadb_repo_setup echo \"d4e4635eeb79b0e96483bd70703209c63da55a236eadd7397f769ee434d92ca8 mariadb_repo_setup\" | sha256sum -c - chmod +x mariadb_repo_setup sudo ./mariadb_repo_setup --mariadb-server-version = \"mariadb-10.6\" sudo apt install libmariadb3 libmariadb-dev sudo python3 -m pip install mariadb Here we have chosen to install it for everyone, but if you used a virtual environment your could do away with the sudo s Install the package Install it directly from PyPi pip install htcollector or alternatively, download it from GitHub git clone https://github.com/varkenvarken/shellyhtcollector2.git cd shellyhtcollector2 python setup.py install Note It might be a good idea to do this inside a virtual environment! Running the server Assuming you have MariaDB running on the same machine with a database (schema) shellyht , and that the user defined in the environment variable DBUSER has enough privileges to create a tables, the following command will create the necessary tables if not yet present and start listening on port 1883 for incoming connections: nohup python3 -m shellyhtcollector & Additional configuration The reporting tools assume that a table StationidToName exists that contains a mapping between StationId and Name. A mapping for a stationid can be added or updated with the mapping tool, for example: cd shellyhtcollector; python3 tools/mapping.py \"shellyht-6A566F\" \"dining room\" Or, since you have the server running now, simply execute a http get http GET \"http://localhost:1883/name?id=shellyht-6A566F&name=dining room\" Generating reports An html file with the last recorded measurements can be generated with: cd shellyhtcollector; python3 tools/last.py --html > index.html Both commands assume that you have set two environment variables DBUSER DBPASSWORD API documentation Available on the GitHub pages of this repo Architecture overview flowchart LR s1[shellyht] --> w[webserver] <--> d[database] s2[shellyht] --> w[webserver] s3[shellyht] --> w[webserver] s4[shellyht] --> w[webserver] Implementation details A ShellyHT can be configured to log temperature and humidity changes to a certain host:port using HTTP. The path of a typical GET request will look for example like: /sensorlog?hum=54&temp=23.4&id=shellyht-6A566F Note The Webserver will only accept GET request that have that exact format! The '/sensorlog' part needs to be configured in the Shelly HT device","title":"Home"},{"location":"#htcollector","text":"Gather incoming temperature and humidity updates from a small swarm of Shellyht devices.","title":"htcollector"},{"location":"#intro","text":"Shelly HT devices can be configured to send their measurements to a configurable server. The server is called using a simple HTTP GET request like http://mymachine:8083/sensorlog?hum=24&temp=42.38&id=shellyht-1234FA where the part http://mymachine:8083/sensorlog is something you configure in the sensor itself. htcollector is a solution that intercepts these requests and logs the data in a database. It also provides means to associate meaningful labels with the station-ids and generate html, json or a png image with the latest measurements.","title":"Intro"},{"location":"#installation-and-use","text":"'htcollector` is a Python package that can be used to implement your own server that intercepts messages from Shelly HT devices or you can use the default server implementation that is part of the package. If you are already working with Docker things are even simpler as the two necessary images are provided as part of this project and available on the GitHub Container Registry","title":"Installation and use"},{"location":"#easy-installation-using-docker","text":"htcollector is provided as an easy to use Docker solution too: You can simply download just a file with environment variables and a docker compose file and start that up with docker compose (watch the long curl lines!): mkdir htcollector-docker cd htcollector-docker mkdir docker cd docker curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/.env > .env curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/docker-compose.yml > docker-compose.yml docker compose -f docker-compose.yml up -d This will download two images and start them as two containers: one running a MariaDB server and one running the htcollector. By default the htcollector is configured to listen on port 8083 for incoming measurements from the devices, but this can be changed of course (or you can change the configuration of your Shelly HT devices). When measurements start getting logged, you can go to the same webserver to get an html page with the last measurements: http://mymachine:8083/html An even nicer looking example is available on http://mymachine:8083/all These pages refer to two additional urls: static/css/stylesheet.css and static/js/layout.js , which are served by the same server. You can also associate a meaningful label with any station, simply go to: http://mymachine:8083/names and click on the device you want to change the label of. Note Tested with Docker version 20.10.12, build 20.10.12-0ubuntu2~20.04.1 / Docker Compose version v2.6.0","title":"Easy installation using Docker"},{"location":"#installation-as-a-library","text":"You can of course build your own solution on top of the htcollector module but that takes a few steps. Installing the htcollector package from Pypi is simple enough but it also depends on the MariaDB connector.","title":"Installation as a library"},{"location":"#install-mariadb-connector-for-python","text":"The mariadb python module is not pure Python and depends on libmariadb , so setup is less straight forward than you would hope: wget https://downloads.mariadb.com/MariaDB/mariadb_repo_setup echo \"d4e4635eeb79b0e96483bd70703209c63da55a236eadd7397f769ee434d92ca8 mariadb_repo_setup\" | sha256sum -c - chmod +x mariadb_repo_setup sudo ./mariadb_repo_setup --mariadb-server-version = \"mariadb-10.6\" sudo apt install libmariadb3 libmariadb-dev sudo python3 -m pip install mariadb Here we have chosen to install it for everyone, but if you used a virtual environment your could do away with the sudo s","title":"Install mariadb connector for Python"},{"location":"#install-the-package","text":"Install it directly from PyPi pip install htcollector or alternatively, download it from GitHub git clone https://github.com/varkenvarken/shellyhtcollector2.git cd shellyhtcollector2 python setup.py install Note It might be a good idea to do this inside a virtual environment!","title":"Install the package"},{"location":"#running-the-server","text":"Assuming you have MariaDB running on the same machine with a database (schema) shellyht , and that the user defined in the environment variable DBUSER has enough privileges to create a tables, the following command will create the necessary tables if not yet present and start listening on port 1883 for incoming connections: nohup python3 -m shellyhtcollector &","title":"Running the server"},{"location":"#additional-configuration","text":"The reporting tools assume that a table StationidToName exists that contains a mapping between StationId and Name. A mapping for a stationid can be added or updated with the mapping tool, for example: cd shellyhtcollector; python3 tools/mapping.py \"shellyht-6A566F\" \"dining room\" Or, since you have the server running now, simply execute a http get http GET \"http://localhost:1883/name?id=shellyht-6A566F&name=dining room\"","title":"Additional configuration"},{"location":"#generating-reports","text":"An html file with the last recorded measurements can be generated with: cd shellyhtcollector; python3 tools/last.py --html > index.html Both commands assume that you have set two environment variables DBUSER DBPASSWORD","title":"Generating reports"},{"location":"#api-documentation","text":"Available on the GitHub pages of this repo","title":"API documentation"},{"location":"#architecture-overview","text":"flowchart LR s1[shellyht] --> w[webserver] <--> d[database] s2[shellyht] --> w[webserver] s3[shellyht] --> w[webserver] s4[shellyht] --> w[webserver]","title":"Architecture overview"},{"location":"#implementation-details","text":"A ShellyHT can be configured to log temperature and humidity changes to a certain host:port using HTTP. The path of a typical GET request will look for example like: /sensorlog?hum=54&temp=23.4&id=shellyht-6A566F Note The Webserver will only accept GET request that have that exact format! The '/sensorlog' part needs to be configured in the Shelly HT device","title":"Implementation details"},{"location":"building-notes/","text":"PyPi !!!Just some documentation for my own workflow on preparing and testing docker images. From the top level directory of this repository we make sure we updatedthe pypi release first if needed (credentials are in ~/.pypirc ): python setup.py sdist twine upload dist/`ls -1 dist/ | tail -1` rm dist/* Verify that it is updated on Pypi . Docker building images docker build -t varkenvarken/htcollector:latest -f docker/Dockerfile . we also depend on a mariadb image with an healthcheck docker build -t varkenvarken/mariadb:latest -f docker/Dockerfile-mariadb . pushing images We my want to push the images (to Docker hub or elsewhere) docker login ... docker push varkenvarken/htcollector:latest docker push varkenvarken/mariadb:latest Verify on their respective repositories: htcollector mariadb testing Run htcollector and the mariadb database together from the compose file: docker-compose -f docker/docker-compose.yml up -d The test it by adding a couple of measurements en then retrieving a graph and an html page: http GET \"http://localhost:8083/sensorlog?hum=70&temp=24&id=test-123456\" ... # perhaps sleep a bit http GET \"http://localhost:8083/sensorlog?hum=65&temp=25&id=test-123456\" http GET \"http://localhost:8083/graph?id=test-123456\" > /tmp/f.png ; display /tmp/f.png deploy on another machine Tested with Docker version 20.10.12, build 20.10.12-0ubuntu2~20.04.1 / Docker Compose version v2.6.0 docker pull varkenvarken/htcollector:latest docker pull varkenvarken/mariadb:latest mkdir htcollector-docker cd htcollector-docker mkdir docker cd docker curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/.env > .env curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/docker-compose.yml > docker-compose.yml docker compose -f docker-compose.yml up -d","title":"Building"},{"location":"building-notes/#pypi","text":"!!!Just some documentation for my own workflow on preparing and testing docker images. From the top level directory of this repository we make sure we updatedthe pypi release first if needed (credentials are in ~/.pypirc ): python setup.py sdist twine upload dist/`ls -1 dist/ | tail -1` rm dist/* Verify that it is updated on Pypi .","title":"PyPi"},{"location":"building-notes/#docker","text":"","title":"Docker"},{"location":"building-notes/#building-images","text":"docker build -t varkenvarken/htcollector:latest -f docker/Dockerfile . we also depend on a mariadb image with an healthcheck docker build -t varkenvarken/mariadb:latest -f docker/Dockerfile-mariadb .","title":"building images"},{"location":"building-notes/#pushing-images","text":"We my want to push the images (to Docker hub or elsewhere) docker login ... docker push varkenvarken/htcollector:latest docker push varkenvarken/mariadb:latest Verify on their respective repositories: htcollector mariadb","title":"pushing images"},{"location":"building-notes/#testing","text":"Run htcollector and the mariadb database together from the compose file: docker-compose -f docker/docker-compose.yml up -d The test it by adding a couple of measurements en then retrieving a graph and an html page: http GET \"http://localhost:8083/sensorlog?hum=70&temp=24&id=test-123456\" ... # perhaps sleep a bit http GET \"http://localhost:8083/sensorlog?hum=65&temp=25&id=test-123456\" http GET \"http://localhost:8083/graph?id=test-123456\" > /tmp/f.png ; display /tmp/f.png","title":"testing"},{"location":"building-notes/#deploy-on-another-machine","text":"Tested with Docker version 20.10.12, build 20.10.12-0ubuntu2~20.04.1 / Docker Compose version v2.6.0 docker pull varkenvarken/htcollector:latest docker pull varkenvarken/mariadb:latest mkdir htcollector-docker cd htcollector-docker mkdir docker cd docker curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/.env > .env curl https://raw.githubusercontent.com/varkenvarken/shellyhtcollector2/master/docker/docker-compose.yml > docker-compose.yml docker compose -f docker-compose.yml up -d","title":"deploy on another machine"},{"location":"apidoc/htcollector.Database/","text":"module htcollector . Database </> Classes Measurement \u2014 Represents a measurement of temperature and humidity by a station. </> MeasurementDatabase \u2014 Implements a databases containing measurements and station descriptions. </> class htcollector.Database . Measurement ( stationid , temperature , humidity ) </> Represents a measurement of temperature and humidity by a station. Parameters stationid (str) \u2014 station identification. Must contain only 1 or more alphnumeric characters or hyphens temperature (float) \u2014 description humidity (float) \u2014 description Raises ValueError \u2014 if the stationid argument contains illegal characters or temperature or humidity arguments are not compatible to floats class htcollector.Database . MeasurementDatabase ( database , host , port , user , password ) </> Implements a databases containing measurements and station descriptions. The backing database should be a MariaDB database server. Parameters database (str) \u2014 name of the database host (str) \u2014 hostname or ip-address of teh database server port (str) \u2014 port that the database server is listening on user (str) \u2014 username of a user with access privileges to the database password (str) \u2014 password of the user Methods names ( stationid , name ) (dict) \u2014 Insert or replace a name for a stationid, or return a list of all stations._ </> retrieveDatetimeBefore ( stationid , t ) (datetime or None) \u2014 Returns the time of the last measurement preceding a given time. </> retrieveLastMeasurement ( stationid , _names , _unique_stations ) (list) \u2014 Return the last measurement data for a station or all stations. </> retrieveMeasurements ( stationid , starttime , endtime ) (list) \u2014 Get measurements inside a given timeframe. </> storeMeasurement ( measurement ) \u2014 Store a measurement into the database. </> method storeMeasurement ( measurement ) </> Store a measurement into the database. Parameters measurement (Measurement) \u2014 the measurement Measurements do not contain timestamps, the are added automatically. method retrieveMeasurements ( stationid , starttime , endtime=None ) </> Get measurements inside a given timeframe. Parameters stationid (str) \u2014 stationid or asterisk '*' starttime (datetime) \u2014 starttime of measurement period (inclusive) endtime (datetime, optional) \u2014 endtime of measurement period (inclusive) or None for now. Defaults to None. Returns (list) of dict(timestamp:t, stationid:id, temperature:t, humidity:h) method retrieveLastMeasurement ( stationid=None , _names=None , _unique_stations=None ) </> Return the last measurement data for a station or all stations. Parameters stationid (str) \u2014 the stationid or an asterisk '*' Returns (list) a list of dict objects, one for each station method retrieveDatetimeBefore ( stationid , t ) </> Returns the time of the last measurement preceding a given time. Parameters stationid (str) \u2014 the station id t (datetime) \u2014 the timestamp Returns (datetime or None) the time of the last measurement preceding a given time or None if the isn one method names ( stationid , name=None ) </> Insert or replace a name for a stationid, or return a list of all stations._ Parameters stationid (str) \u2014 the shellyht station id or an asterisk '*' name (str) \u2014 the name to associate with a stationid (ignored if stationid is '*') Returns (dict) a dict(stationid:name)","title":"htcollector.Database"},{"location":"apidoc/htcollector.Database/#htcollectordatabase","text":"</> Classes Measurement \u2014 Represents a measurement of temperature and humidity by a station. </> MeasurementDatabase \u2014 Implements a databases containing measurements and station descriptions. </> class","title":"htcollector.Database"},{"location":"apidoc/htcollector.Database/#htcollectordatabasemeasurement","text":"</> Represents a measurement of temperature and humidity by a station. Parameters stationid (str) \u2014 station identification. Must contain only 1 or more alphnumeric characters or hyphens temperature (float) \u2014 description humidity (float) \u2014 description Raises ValueError \u2014 if the stationid argument contains illegal characters or temperature or humidity arguments are not compatible to floats class","title":"htcollector.Database.Measurement"},{"location":"apidoc/htcollector.Database/#htcollectordatabasemeasurementdatabase","text":"</> Implements a databases containing measurements and station descriptions. The backing database should be a MariaDB database server. Parameters database (str) \u2014 name of the database host (str) \u2014 hostname or ip-address of teh database server port (str) \u2014 port that the database server is listening on user (str) \u2014 username of a user with access privileges to the database password (str) \u2014 password of the user Methods names ( stationid , name ) (dict) \u2014 Insert or replace a name for a stationid, or return a list of all stations._ </> retrieveDatetimeBefore ( stationid , t ) (datetime or None) \u2014 Returns the time of the last measurement preceding a given time. </> retrieveLastMeasurement ( stationid , _names , _unique_stations ) (list) \u2014 Return the last measurement data for a station or all stations. </> retrieveMeasurements ( stationid , starttime , endtime ) (list) \u2014 Get measurements inside a given timeframe. </> storeMeasurement ( measurement ) \u2014 Store a measurement into the database. </> method","title":"htcollector.Database.MeasurementDatabase"},{"location":"apidoc/htcollector.Database/#htcollectordatabasemeasurementdatabasestoremeasurement","text":"</> Store a measurement into the database. Parameters measurement (Measurement) \u2014 the measurement Measurements do not contain timestamps, the are added automatically. method","title":"htcollector.Database.MeasurementDatabase.storeMeasurement"},{"location":"apidoc/htcollector.Database/#htcollectordatabasemeasurementdatabaseretrievemeasurements","text":"</> Get measurements inside a given timeframe. Parameters stationid (str) \u2014 stationid or asterisk '*' starttime (datetime) \u2014 starttime of measurement period (inclusive) endtime (datetime, optional) \u2014 endtime of measurement period (inclusive) or None for now. Defaults to None. Returns (list) of dict(timestamp:t, stationid:id, temperature:t, humidity:h) method","title":"htcollector.Database.MeasurementDatabase.retrieveMeasurements"},{"location":"apidoc/htcollector.Database/#htcollectordatabasemeasurementdatabaseretrievelastmeasurement","text":"</> Return the last measurement data for a station or all stations. Parameters stationid (str) \u2014 the stationid or an asterisk '*' Returns (list) a list of dict objects, one for each station method","title":"htcollector.Database.MeasurementDatabase.retrieveLastMeasurement"},{"location":"apidoc/htcollector.Database/#htcollectordatabasemeasurementdatabaseretrievedatetimebefore","text":"</> Returns the time of the last measurement preceding a given time. Parameters stationid (str) \u2014 the station id t (datetime) \u2014 the timestamp Returns (datetime or None) the time of the last measurement preceding a given time or None if the isn one method","title":"htcollector.Database.MeasurementDatabase.retrieveDatetimeBefore"},{"location":"apidoc/htcollector.Database/#htcollectordatabasemeasurementdatabasenames","text":"</> Insert or replace a name for a stationid, or return a list of all stations._ Parameters stationid (str) \u2014 the shellyht station id or an asterisk '*' name (str) \u2014 the name to associate with a stationid (ignored if stationid is '*') Returns (dict) a dict(stationid:name)","title":"htcollector.Database.MeasurementDatabase.names"},{"location":"apidoc/htcollector.Server/","text":"module htcollector . Server </> Classes InterceptorHandlerFactory \u2014 Provides a single handler that returns an InterceptorHandler(BaseHTTPRequestHandler) that writes measurements to the provided MeasurementDatabase. </> Interceptor \u2014 Base class for various socket-based server classes. </> class htcollector.Server . InterceptorHandlerFactory ( ) </> Provides a single handler that returns an InterceptorHandler(BaseHTTPRequestHandler) that writes measurements to the provided MeasurementDatabase. class htcollector.Server . Interceptor ( server_address , db , static_directory ) </> Bases http.server.HTTPServer socketserver.TCPServer socketserver.BaseServer Base class for various socket-based server classes. Defaults to synchronous IP stream (i.e., TCP). Methods for the caller: init (server_address, RequestHandlerClass, bind_and_activate=True) serve_forever(poll_interval=0.5) shutdown() handle_request() # if you don't use serve_forever() fileno() -> int # for selector Methods that may be overridden: server_bind() server_activate() get_request() -> request, client_address handle_timeout() verify_request(request, client_address) process_request(request, client_address) shutdown_request(request) close_request(request) handle_error() Methods for derived classes: finish_request(request, client_address) Class variables that may be overridden by derived classes or instances: timeout address_family socket_type request_queue_size (only for stream sockets) allow_reuse_address Instance variables: server_address RequestHandlerClass socket Methods close_request ( request ) \u2014 Called to clean up an individual request. </> fileno ( ) \u2014 Return socket file number. </> finish_request ( request , client_address ) \u2014 Finish one request by instantiating RequestHandlerClass. </> get_request ( ) \u2014 Get the request and client address from the socket. </> handle_error ( request , client_address ) \u2014 Handle an error gracefully. May be overridden. </> handle_request ( ) \u2014 Handle one request, possibly blocking. </> handle_timeout ( ) \u2014 Called if no new request arrives within self.timeout. </> process_request ( request , client_address ) \u2014 Call finish_request. </> serve_forever ( poll_interval ) \u2014 Handle one request at a time until shutdown. </> server_activate ( ) \u2014 Called by constructor to activate the server. </> server_bind ( ) \u2014 Override server_bind to store the server name. </> server_close ( ) \u2014 Called to clean-up the server. </> service_actions ( ) \u2014 Called by the serve_forever() loop. </> shutdown ( ) \u2014 Stops the serve_forever loop. </> shutdown_request ( request ) \u2014 Called to shutdown and close an individual request. </> verify_request ( request , client_address ) \u2014 Verify the request. May be overridden. </> method serve_forever ( poll_interval=0.5 ) </> Handle one request at a time until shutdown. Polls for shutdown every poll_interval seconds. Ignores self.timeout. If you need to do periodic tasks, do them in another thread. method shutdown ( ) </> Stops the serve_forever loop. Blocks until the loop has finished. This must be called while serve_forever() is running in another thread, or it will deadlock. method service_actions ( ) </> Called by the serve_forever() loop. May be overridden by a subclass / Mixin to implement any code that needs to be run during the loop. method handle_request ( ) </> Handle one request, possibly blocking. Respects self.timeout. method handle_timeout ( ) </> Called if no new request arrives within self.timeout. Overridden by ForkingMixIn. method verify_request ( request , client_address ) </> Verify the request. May be overridden. Return True if we should proceed with this request. method process_request ( request , client_address ) </> Call finish_request. Overridden by ForkingMixIn and ThreadingMixIn. method finish_request ( request , client_address ) </> Finish one request by instantiating RequestHandlerClass. method handle_error ( request , client_address ) </> Handle an error gracefully. May be overridden. The default is to print a traceback and continue. method server_activate ( ) </> Called by constructor to activate the server. May be overridden. method server_close ( ) </> Called to clean-up the server. May be overridden. method fileno ( ) </> Return socket file number. Interface required by selector. method get_request ( ) </> Get the request and client address from the socket. May be overridden. method shutdown_request ( request ) </> Called to shutdown and close an individual request. method close_request ( request ) </> Called to clean up an individual request. method server_bind ( ) </> Override server_bind to store the server name.","title":"htcollector.Server"},{"location":"apidoc/htcollector.Server/#htcollectorserver","text":"</> Classes InterceptorHandlerFactory \u2014 Provides a single handler that returns an InterceptorHandler(BaseHTTPRequestHandler) that writes measurements to the provided MeasurementDatabase. </> Interceptor \u2014 Base class for various socket-based server classes. </> class","title":"htcollector.Server"},{"location":"apidoc/htcollector.Server/#htcollectorserverinterceptorhandlerfactory","text":"</> Provides a single handler that returns an InterceptorHandler(BaseHTTPRequestHandler) that writes measurements to the provided MeasurementDatabase. class","title":"htcollector.Server.InterceptorHandlerFactory"},{"location":"apidoc/htcollector.Server/#htcollectorserverinterceptor","text":"</> Bases http.server.HTTPServer socketserver.TCPServer socketserver.BaseServer Base class for various socket-based server classes. Defaults to synchronous IP stream (i.e., TCP). Methods for the caller: init (server_address, RequestHandlerClass, bind_and_activate=True) serve_forever(poll_interval=0.5) shutdown() handle_request() # if you don't use serve_forever() fileno() -> int # for selector Methods that may be overridden: server_bind() server_activate() get_request() -> request, client_address handle_timeout() verify_request(request, client_address) process_request(request, client_address) shutdown_request(request) close_request(request) handle_error() Methods for derived classes: finish_request(request, client_address) Class variables that may be overridden by derived classes or instances: timeout address_family socket_type request_queue_size (only for stream sockets) allow_reuse_address Instance variables: server_address RequestHandlerClass socket Methods close_request ( request ) \u2014 Called to clean up an individual request. </> fileno ( ) \u2014 Return socket file number. </> finish_request ( request , client_address ) \u2014 Finish one request by instantiating RequestHandlerClass. </> get_request ( ) \u2014 Get the request and client address from the socket. </> handle_error ( request , client_address ) \u2014 Handle an error gracefully. May be overridden. </> handle_request ( ) \u2014 Handle one request, possibly blocking. </> handle_timeout ( ) \u2014 Called if no new request arrives within self.timeout. </> process_request ( request , client_address ) \u2014 Call finish_request. </> serve_forever ( poll_interval ) \u2014 Handle one request at a time until shutdown. </> server_activate ( ) \u2014 Called by constructor to activate the server. </> server_bind ( ) \u2014 Override server_bind to store the server name. </> server_close ( ) \u2014 Called to clean-up the server. </> service_actions ( ) \u2014 Called by the serve_forever() loop. </> shutdown ( ) \u2014 Stops the serve_forever loop. </> shutdown_request ( request ) \u2014 Called to shutdown and close an individual request. </> verify_request ( request , client_address ) \u2014 Verify the request. May be overridden. </> method","title":"htcollector.Server.Interceptor"},{"location":"apidoc/htcollector.Server/#socketserverbaseserverserve_forever","text":"</> Handle one request at a time until shutdown. Polls for shutdown every poll_interval seconds. Ignores self.timeout. If you need to do periodic tasks, do them in another thread. method","title":"socketserver.BaseServer.serve_forever"},{"location":"apidoc/htcollector.Server/#socketserverbaseservershutdown","text":"</> Stops the serve_forever loop. Blocks until the loop has finished. This must be called while serve_forever() is running in another thread, or it will deadlock. method","title":"socketserver.BaseServer.shutdown"},{"location":"apidoc/htcollector.Server/#socketserverbaseserverservice_actions","text":"</> Called by the serve_forever() loop. May be overridden by a subclass / Mixin to implement any code that needs to be run during the loop. method","title":"socketserver.BaseServer.service_actions"},{"location":"apidoc/htcollector.Server/#socketserverbaseserverhandle_request","text":"</> Handle one request, possibly blocking. Respects self.timeout. method","title":"socketserver.BaseServer.handle_request"},{"location":"apidoc/htcollector.Server/#socketserverbaseserverhandle_timeout","text":"</> Called if no new request arrives within self.timeout. Overridden by ForkingMixIn. method","title":"socketserver.BaseServer.handle_timeout"},{"location":"apidoc/htcollector.Server/#socketserverbaseserververify_request","text":"</> Verify the request. May be overridden. Return True if we should proceed with this request. method","title":"socketserver.BaseServer.verify_request"},{"location":"apidoc/htcollector.Server/#socketserverbaseserverprocess_request","text":"</> Call finish_request. Overridden by ForkingMixIn and ThreadingMixIn. method","title":"socketserver.BaseServer.process_request"},{"location":"apidoc/htcollector.Server/#socketserverbaseserverfinish_request","text":"</> Finish one request by instantiating RequestHandlerClass. method","title":"socketserver.BaseServer.finish_request"},{"location":"apidoc/htcollector.Server/#socketserverbaseserverhandle_error","text":"</> Handle an error gracefully. May be overridden. The default is to print a traceback and continue. method","title":"socketserver.BaseServer.handle_error"},{"location":"apidoc/htcollector.Server/#socketservertcpserverserver_activate","text":"</> Called by constructor to activate the server. May be overridden. method","title":"socketserver.TCPServer.server_activate"},{"location":"apidoc/htcollector.Server/#socketservertcpserverserver_close","text":"</> Called to clean-up the server. May be overridden. method","title":"socketserver.TCPServer.server_close"},{"location":"apidoc/htcollector.Server/#socketservertcpserverfileno","text":"</> Return socket file number. Interface required by selector. method","title":"socketserver.TCPServer.fileno"},{"location":"apidoc/htcollector.Server/#socketservertcpserverget_request","text":"</> Get the request and client address from the socket. May be overridden. method","title":"socketserver.TCPServer.get_request"},{"location":"apidoc/htcollector.Server/#socketservertcpservershutdown_request","text":"</> Called to shutdown and close an individual request. method","title":"socketserver.TCPServer.shutdown_request"},{"location":"apidoc/htcollector.Server/#socketservertcpserverclose_request","text":"</> Called to clean up an individual request. method","title":"socketserver.TCPServer.close_request"},{"location":"apidoc/htcollector.Server/#httpserverhttpserverserver_bind","text":"</> Override server_bind to store the server name.","title":"http.server.HTTPServer.server_bind"},{"location":"apidoc/htcollector.Utils/","text":"module htcollector . Utils </> Classes DatetimeEncoder \u2014 Extensible JSON http://json.org encoder for Python data structures. </> class htcollector.Utils . DatetimeEncoder ( skipkeys=False , ensure_ascii=True , check_circular=True , allow_nan=True , sort_keys=False , indent=None , separators=None , default=None ) </> Bases json.encoder.JSONEncoder Extensible JSON http://json.org encoder for Python data structures. Supports the following objects and types by default: +-------------------+---------------+ | Python | JSON | +===================+===============+ | dict | object | +-------------------+---------------+ | list, tuple | array | +-------------------+---------------+ | str | string | +-------------------+---------------+ | int, float | number | +-------------------+---------------+ | True | true | +-------------------+---------------+ | False | false | +-------------------+---------------+ | None | null | +-------------------+---------------+ To extend this to recognize other objects, subclass and implement a .default() method with another method that returns a serializable object for o if possible, otherwise it should call the superclass implementation (to raise TypeError ). Methods default ( obj ) \u2014 Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). </> encode ( o ) \u2014 Return a JSON string representation of a Python data structure. </> iterencode ( o , _one_shot ) \u2014 Encode the given object and yield each string representation as available. </> method encode ( o ) </> Return a JSON string representation of a Python data structure. >>> from json.encoder import JSONEncoder >>> JSONEncoder () . encode ({ \"foo\" : [ \"bar\" , \"baz\" ]}) '{\"foo\": [\"bar\", \"baz\"]}' method iterencode ( o , _one_shot=False ) </> Encode the given object and yield each string representation as available. For example:: for chunk in JSONEncoder () . iterencode ( bigobject ) : mysocket . write ( chunk ) method default ( obj ) </> Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). For example, to support arbitrary iterators, you could implement default like this:: def default ( self , o ) : try : iterable = iter ( o ) except TypeError : pass else : return list ( iterable ) # Let the base class default method raise the TypeError return JSONEncoder . default ( self , o )","title":"htcollector.Utils"},{"location":"apidoc/htcollector.Utils/#htcollectorutils","text":"</> Classes DatetimeEncoder \u2014 Extensible JSON http://json.org encoder for Python data structures. </> class","title":"htcollector.Utils"},{"location":"apidoc/htcollector.Utils/#htcollectorutilsdatetimeencoder","text":"</> Bases json.encoder.JSONEncoder Extensible JSON http://json.org encoder for Python data structures. Supports the following objects and types by default: +-------------------+---------------+ | Python | JSON | +===================+===============+ | dict | object | +-------------------+---------------+ | list, tuple | array | +-------------------+---------------+ | str | string | +-------------------+---------------+ | int, float | number | +-------------------+---------------+ | True | true | +-------------------+---------------+ | False | false | +-------------------+---------------+ | None | null | +-------------------+---------------+ To extend this to recognize other objects, subclass and implement a .default() method with another method that returns a serializable object for o if possible, otherwise it should call the superclass implementation (to raise TypeError ). Methods default ( obj ) \u2014 Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). </> encode ( o ) \u2014 Return a JSON string representation of a Python data structure. </> iterencode ( o , _one_shot ) \u2014 Encode the given object and yield each string representation as available. </> method","title":"htcollector.Utils.DatetimeEncoder"},{"location":"apidoc/htcollector.Utils/#jsonencoderjsonencoderencode","text":"</> Return a JSON string representation of a Python data structure. >>> from json.encoder import JSONEncoder >>> JSONEncoder () . encode ({ \"foo\" : [ \"bar\" , \"baz\" ]}) '{\"foo\": [\"bar\", \"baz\"]}' method","title":"json.encoder.JSONEncoder.encode"},{"location":"apidoc/htcollector.Utils/#jsonencoderjsonencoderiterencode","text":"</> Encode the given object and yield each string representation as available. For example:: for chunk in JSONEncoder () . iterencode ( bigobject ) : mysocket . write ( chunk ) method","title":"json.encoder.JSONEncoder.iterencode"},{"location":"apidoc/htcollector.Utils/#htcollectorutilsdatetimeencoderdefault","text":"</> Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). For example, to support arbitrary iterators, you could implement default like this:: def default ( self , o ) : try : iterable = iter ( o ) except TypeError : pass else : return list ( iterable ) # Let the base class default method raise the TypeError return JSONEncoder . default ( self , o )","title":"htcollector.Utils.DatetimeEncoder.default"},{"location":"apidoc/htcollector/","text":"package htcollector </> This package can be invoked as a module. Example nohup python -m shellyhtcollector -p 1883 & If invoked this way, it will start listening for data on port 1883. For more info run it with the -- help option python -m shellyhtcollector --help","title":"htcollector"},{"location":"apidoc/htcollector/#htcollector","text":"</> This package can be invoked as a module. Example nohup python -m shellyhtcollector -p 1883 & If invoked this way, it will start listening for data on port 1883. For more info run it with the -- help option python -m shellyhtcollector --help","title":"htcollector"},{"location":"apidoc/source/htcollector.Database/","text":"SOURCE CODE htcollector. Database DOCS # shellyhtcollector, a python module to process sensor readings from Shelly H&T devices # # (C) 2022 Michel Anders (varkenvarken) # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; either version 2 of the License, or # (at your option) any later version. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # GNU General Public License for more details. # # You should have received a copy of the GNU General Public License # along with this program; if not, write to the Free Software # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, # MA 02110-1301, USA. # # version: 20220828123631 import logging import re import mariadb from datetime import datetime , timedelta from dateutil import tz class Measurement : DOCS \"\"\" Represents a measurement of temperature and humidity by a station. Args: stationid (str): station identification. Must contain only 1 or more alphnumeric characters or hyphens temperature (float): _description_ humidity (float): _description_ Raises: ValueError: if the stationid argument contains illegal characters or temperature or humidity arguments are not compatible to floats \"\"\" idchars = re . compile ( r \"^[a-z01-9-]+$\" , re . IGNORECASE ) def __init__ ( self , stationid , temperature , humidity ): if re . match ( self . idchars , stationid ): self . stationid = stationid else : raise ValueError ( \"stationid argument contains illegal characters\" ) try : self . temperature = float ( temperature ) self . humidity = float ( humidity ) except ValueError as e : e . args = ( \"temperature and humidity arguments most be floats or convertible to floats\" , ) raise e def __repr__ ( self ): return f 'Measurement(\" { self . stationid } \", { self . temperature } , { self . humidity } )' class MeasurementDatabase : DOCS \"\"\" Implements a databases containing measurements and station descriptions. The backing database should be a MariaDB database server. Args: database (str): name of the database host (str): hostname or ip-address of teh database server port (str): port that the database server is listening on user (str): username of a user with access privileges to the database password (str): password of the user \"\"\" def __init__ ( self , database , host , port , user , password ): self . pool = mariadb . ConnectionPool ( pool_name = \"connection_pool_1\" , user = user , password = password , host = host , database = database , ) with self . pool . get_connection () as connection : connection . auto_reconnect = True # the timestamp is configured for millisecond resolution with connection . cursor () as cursor : cursor . execute ( \"\"\"CREATE TABLE IF NOT EXISTS Measurements( Timestamp DATETIME(3) DEFAULT CURRENT_TIMESTAMP, Stationid VARCHAR(100), Temperature REAL, Humidity REAL);\"\"\" ) cursor . execute ( \"\"\"CREATE INDEX IF NOT EXISTS ts ON Measurements(Timestamp);\"\"\" ) cursor . execute ( \"\"\"CREATE INDEX IF NOT EXISTS si ON Measurements(Stationid);\"\"\" ) cursor . execute ( \"\"\"CREATE TABLE IF NOT EXISTS StationidToName( Stationid VARCHAR(100) NOT NULL PRIMARY KEY, Name TEXT NOT NULL);\"\"\" ) def storeMeasurement ( self , measurement ): DOCS \"\"\" Store a measurement into the database. Args: measurement (Measurement): the measurement Measurements do not contain timestamps, the are added automatically. \"\"\" with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( \"\"\"INSERT INTO Measurements(Stationid, Temperature, Humidity) VALUES (?,?,?)\"\"\" , ( measurement . stationid , measurement . temperature , measurement . humidity , ), ) connection . commit () n = cursor . rowcount cursor . close () return n def retrieveMeasurements ( DOCS self , stationid , starttime : datetime , endtime : datetime = None ): \"\"\" Get measurements inside a given timeframe. Args: stationid (str): stationid or asterisk '*' starttime (datetime): starttime of measurement period (inclusive) endtime (datetime, optional): endtime of measurement period (inclusive) or None for now. Defaults to None. Returns: list: of dict(timestamp:t, stationid:id, temperature:t, humidity:h) \"\"\" # timestamps in MariaDB are stored in UTC endtime = ( endtime . astimezone ( tz . UTC ) if endtime is not None else datetime . now ( tz = tz . UTC ) ) starttime = starttime . astimezone ( tz . UTC ) starttime = starttime . replace ( microsecond = ( starttime . microsecond // 1000 ) * 1000 ) # round down to millis if stationid == \"*\" : with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( f \"\"\"SELECT Timestamp, Stationid, Temperature, Humidity FROM Measurements WHERE Timestamp >= ? AND Timestamp <= ?\"\"\" , ( starttime , endtime ), ) rows = cursor . fetchall () else : with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( f \"\"\"SELECT Timestamp, Stationid, Temperature, Humidity FROM Measurements WHERE Stationid = ? AND Timestamp >= ? AND Timestamp <= ?\"\"\" , ( stationid , starttime , endtime ), ) rows = cursor . fetchall () # mariadb / mysql timestamps are in UTC but returned as 'naive' datetime objects rows = [ { \"timestamp\" : row [ 0 ] . replace ( tzinfo = tz . UTC ) . astimezone ( tz . tzlocal ()), \"stationid\" : row [ 1 ], \"temperature\" : row [ 2 ], \"humidity\" : row [ 3 ], } for row in rows ] return rows def retrieveLastMeasurement ( DOCS self , stationid = None , _names = None , _unique_stations = None ): \"\"\" Return the last measurement data for a station or all stations. Args: stationid (str): the stationid or an asterisk '*' Returns: list: a list of dict objects, one for each station \"\"\" logging . debug ( \"retrieveLastMeasurement\" , stationid , _names , _unique_stations ) if _names is None : _names = { nm [ 0 ]: nm [ 1 ] for nm in self . names ( \"*\" )} if _unique_stations is None : _unique_stations = self . uniqueStations () if stationid is None : rows = [] for unique_station in _unique_stations : rows . extend ( self . retrieveLastMeasurement ( unique_station , _names = _names , _unique_stations = _unique_stations ) ) else : # get the data with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( \"\"\"SELECT Timestamp as 'Timestamp [timestamp]', Stationid, Temperature, Humidity FROM Measurements WHERE Stationid = ? ORDER BY timestamp DESC LIMIT 1;\"\"\" , ( stationid ,), ) rows = cursor . fetchall () # mariadb / mysql timestamps are in UTC but returned as 'naive' datetime objects logging . info ( f \"retrieveLastMeasurement { stationid } , { rows } \" ) rows = [ { \"time\" : row [ 0 ] . replace ( tzinfo = tz . UTC ), \"deltat\" : datetime . now () - row [ 0 ], \"stationid\" : row [ 1 ], \"name\" : _names . get ( row [ 1 ], \"unknown\" ), \"temperature\" : row [ 2 ], \"humidity\" : row [ 3 ], } for row in rows ] return rows def retrieveDatetimeBefore ( self , stationid : str , t : datetime ): DOCS \"\"\" Returns the time of the last measurement preceding a given time. Args: stationid (str): the station id t (datetime): the timestamp Returns: datetime or None: the time of the last measurement preceding a given time or None if the isn one \"\"\" t = t . astimezone ( tz = tz . UTC ) logging . debug ( \"retrieveDatetimeBefore\" , stationid , t ) with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( \"\"\"SELECT Timestamp FROM Measurements WHERE Stationid = ? AND Timestamp < ? ORDER BY Timestamp DESC LIMIT 1\"\"\" , ( stationid , t ), ) rows = cursor . fetchall () print ( t , rows , flush = True ) # mariadb / mysql timestamps are in UTC but returned as 'naive' datetime objects return rows [ 0 ][ 0 ] . replace ( tzinfo = tz . UTC ) if len ( rows ) else None def uniqueStations ( self ): with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( \"SELECT DISTINCT(Stationid) FROM Measurements\" ) return [ row [ 0 ] for row in cursor . fetchall ()] def names ( self , stationid , name = None ): DOCS \"\"\" Insert or replace a name for a stationid, or return a list of all stations._ Args: stationid (str): the shellyht station id or an asterisk '*' name (str)): the name to associate with a stationid (ignored if stationid is '*') Returns: dict: a dict(stationid:name) \"\"\" if stationid == \"*\" : stationids = self . uniqueStations () with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( \"SELECT * FROM StationidToName\" ) rows = cursor . fetchall () print ( \"names>>>\" , rows ) stationmap = { row [ 0 ]: row [ 1 ] for row in rows } for s in stationids : if s not in stationmap : stationmap [ s ] = \"Unknown\" return stationmap else : with self . pool . get_connection () as connection : connection . auto_reconnect = True with connection . cursor () as cursor : cursor . execute ( \"REPLACE StationidToName(Stationid, Name) VALUES(?,?)\" , ( stationid , name ), ) connection . commit () return self . names ( \"*\" )","title":"htcollector.Database"},{"location":"apidoc/source/htcollector.Server/","text":"SOURCE CODE htcollector. Server DOCS # shellyhtcollector, a python module to process sensor readings from Shelly H&T devices # # (C) 2022 Michel Anders (varkenvarken) # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; either version 2 of the License, or # (at your option) any later version. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # GNU General Public License for more details. # # You should have received a copy of the GNU General Public License # along with this program; if not, write to the Free Software # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, # MA 02110-1301, USA. # # version: 20220828130742 from json import dumps import mimetypes from pathlib import Path import re from io import BytesIO as IO from datetime import datetime , timedelta from dateutil import tz from http import HTTPStatus from http.server import BaseHTTPRequestHandler , HTTPServer from urllib.parse import urlparse , quote , unquote_plus , parse_qs import cgi import logging from .Database import Measurement from .Utils import DatetimeEncoder class InterceptorHandlerFactory : DOCS \"\"\" Provides a single handler that returns an InterceptorHandler(BaseHTTPRequestHandler) that writes measurements to the provided MeasurementDatabase. \"\"\" @staticmethod def getHandler ( db , static_directory ): class InterceptorHandler ( BaseHTTPRequestHandler ): querypattern = re . compile ( r \"^/sensorlog\\?hum=(?P<humidity>\\d+(\\.\\d+)?)\\&temp=(?P<temperature>\\d+(\\.\\d+)?)\\&id=(?P<stationid>[a-z01-9-]+)$\" , re . IGNORECASE , ) htmlpattern = re . compile ( r \"^/html(\\?id=(?P<stationid>[a-z01-9-]+))?$\" , re . IGNORECASE , ) allpattern = re . compile ( r \"^/all$\" , re . IGNORECASE , ) jsonpattern = re . compile ( r \"^/json(?P<p24>/24)?(\\?id=(?P<stationid>[a-z01-9-]+))?$\" , re . IGNORECASE , ) namespattern = re . compile ( r \"^/names$\" , re . IGNORECASE , ) updatenamepattern = re . compile ( r \"^/name$\" , re . IGNORECASE , ) staticpattern = re . compile ( r \"^(/static/(?P<resource>.*))|/$\" , re . IGNORECASE , ) faviconpattern = re . compile ( r \"^/favicon.ico$\" ) def send_response ( self , code , message = None ): \"\"\"Add the response header to the headers buffer and log the response code. Overridden to leave out Server header (leaks information) \"\"\" self . log_request ( code ) self . send_response_only ( code , message ) # self.send_header('Server', self.version_string()) self . send_header ( \"Date\" , self . date_time_string ()) @staticmethod def checkPath ( path : Path ): for p in path . parts : if p in { \".\" , \"..\" }: raise ValueError ( \"relative paths are forbidden\" ) @staticmethod def getTimeseries ( db , stationid ): mark = datetime . now () - timedelta ( days = 1 ) mtime = db . retrieveDatetimeBefore ( stationid , mark ) return db . retrieveMeasurements ( stationid , mtime if mtime is not None else mark , ) def common_headers ( self ): \"the checksum is for the inline script in the updatename.html\" self . send_header ( \"Content-Security-Policy\" , \"default-src 'self'; script-src 'self' https://cdn.jsdelivr.net/npm/ 'sha256-m/VYsp+J+CFMn+MvBg+XMDwm67RMydRIm5ltf4j4nRk='; object-src 'none'; base-uri 'self'; frame-ancestors 'self';\" , ) self . send_header ( \"X-Content-Type-Options\" , \"nosniff\" ) def do_GET ( self ): logging . info ( self . path ) try : if re . match ( self . faviconpattern , self . path ): filepath = Path ( static_directory ) / \"favicon.ico\" mime_type = mimetypes . guess_type ( filepath )[ 0 ] try : with open ( filepath , \"rb\" ) as f : b = f . read () self . send_response ( HTTPStatus . OK ) self . send_header ( \"Content-type\" , mime_type ) self . send_header ( \"Content-Length\" , str ( len ( b ))) self . end_headers () self . wfile . write ( b ) return except FileNotFoundError : self . send_response ( HTTPStatus . NOT_FOUND ) if m := re . match ( self . querypattern , self . path ): measurement = Measurement ( m . group ( \"stationid\" ), m . group ( \"temperature\" ), m . group ( \"humidity\" ), ) db . storeMeasurement ( measurement ) self . send_response ( HTTPStatus . OK ) elif m := re . match ( self . htmlpattern , self . path ): ms = db . retrieveLastMeasurement ( m . group ( \"stationid\" )) mdivs = \" \\n \" . join ( f \"\"\" <div class=\"measurement { ' late' if m [ 'deltat' ] . total_seconds () > 24 * 3600 else '' } \" id=\" { m [ \"stationid\" ] } \"> <div class=\"station\"> { m [ \"name\" ] } </div> <div class=\"time\" data-time=\" { m [ \"time\" ] } \"></div> <div class=\"temp\"> { m [ \"temperature\" ] : .1f } <span class=\"degrees\">\u00b0C</span></div> <div class=\"hum\"> { m [ \"humidity\" ] : .0f } <span class=percent>%</span></div> </div>\"\"\" for m in ms ) html = bytes ( f \"\"\" <html> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"refresh\" content=\"300\"> <title>Temperatuur binnen</title> <link href=\"static/css/stylesheet.css\" rel=\"stylesheet\"></head> <body> <div class=\"measurements\"> { mdivs } </div> </body> <script>document.querySelectorAll(\"[data-time]\").forEach(function(e) {{ d=new Date(e.getAttribute(\"data-time\"));e.innerHTML=d.getHours() + \":\" + d.getMinutes().toString().padStart(2, '0') }} )</script> </html> \"\"\" , \"UTF-8\" , ) self . send_response ( HTTPStatus . OK ) self . send_header ( \"Content-type\" , \"text/html\" ) self . send_header ( \"Content-Length\" , str ( len ( html ))) self . common_headers () self . end_headers () self . wfile . write ( html ) return elif m := re . match ( self . allpattern , self . path ): last_measurements = db . retrieveLastMeasurement () station_data = dumps ( last_measurements , cls = DatetimeEncoder , ) time_series = { s [ \"stationid\" ]: InterceptorHandler . getTimeseries ( db , s [ \"stationid\" ] ) for s in last_measurements } temperature_data_map = dumps ( time_series , cls = DatetimeEncoder ) html = bytes ( \"\"\"<html> <script src=\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js\" integrity=\"sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=\" crossorigin=\"anonymous\"></script> <script src=\"https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js\" integrity=\"sha256-+8RZJua0aEWg+QVVKg4LEzEEm/8RFez5Tb4JBNiV5xA=\" crossorigin=\"anonymous\"></script> <script src=\"https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js\"></script> <head> <meta charset=\"UTF-8\"> <meta http-equiv=\"refresh\" content=\"300\"> <title>Indoor temperature</title> <link href=\"static/css/stylesheet.css\" rel=\"stylesheet\"> </head> <body> <div id=\"measurements\"></div> </body> <script> station_data = \"\"\" + station_data + \"\"\"; temperature_data_map = \"\"\" + temperature_data_map + \"\"\"; </script> <script src=\"static/js/layout.js\"></script> </html> \"\"\" , \"UTF-8\" , ) self . send_response ( HTTPStatus . OK ) self . send_header ( \"Content-type\" , \"text/html\" ) self . send_header ( \"Content-Length\" , str ( len ( html ))) self . common_headers () self . end_headers () self . wfile . write ( html ) return elif m := re . match ( self . jsonpattern , self . path ): if m . group ( \"p24\" ) is not None : mark = datetime . now () - timedelta ( days = 1 ) mtime = db . retrieveDatetimeBefore ( m . group ( \"stationid\" ), mark ) json = bytes ( dumps ( db . retrieveMeasurements ( m . group ( \"stationid\" ), mtime if mtime is not None else mark , ), cls = DatetimeEncoder , ), encoding = \"UTF-8\" , ) else : json = bytes ( dumps ( db . retrieveLastMeasurement ( m . group ( \"stationid\" )), cls = DatetimeEncoder , ), encoding = \"UTF-8\" , ) self . send_response ( HTTPStatus . OK ) self . send_header ( \"Content-type\" , \"application/json\" ) self . send_header ( \"Content-Length\" , str ( len ( json ))) self . common_headers () self . end_headers () self . wfile . write ( json ) return elif m := re . match ( self . namespattern , self . path ): names = db . names ( \"*\" ) names = \" \\n \" . join ( f '<tr><td> { s } </td><td> { n } </td><td><a href=\"/static/updatename.html?id= { quote ( s ) } &name= { quote ( n ) } \">Change</a></td></tr>' for s , n in names . items () ) self . send_response ( HTTPStatus . OK ) html = f \"\"\"<html><body> <table> { names } </table> </body></html> \"\"\" self . send_header ( \"Content-type\" , \"text/html\" ) self . send_header ( \"Content-Length\" , str ( len ( html ))) self . common_headers () self . end_headers () self . wfile . write ( bytes ( html , \"UTF-8\" )) return elif m := re . match ( self . staticpattern , self . path ): path = urlparse ( m . group ( \"resource\" )) . path filepath = Path ( static_directory ) / ( path . decode () if type ( path ) is bytes else path ) # TODO check encoding URLs are not UTF-8? try : InterceptorHandler . checkPath ( filepath ) except ValueError : self . send_response_only ( HTTPStatus . FORBIDDEN ) if filepath . is_dir (): filepath /= \"index.html\" mime_type = mimetypes . guess_type ( filepath )[ 0 ] try : with open ( filepath , \"rb\" ) as f : b = f . read () self . send_response ( HTTPStatus . OK ) self . send_header ( \"Content-type\" , mime_type ) self . send_header ( \"Content-Length\" , str ( len ( b ))) self . common_headers () self . end_headers () self . wfile . write ( b ) return except FileNotFoundError : self . send_response ( HTTPStatus . NOT_FOUND ) else : self . send_response_only ( HTTPStatus . FORBIDDEN ) except Exception as e : logging . exception ( e ) self . send_response_only ( HTTPStatus . INTERNAL_SERVER_ERROR ) self . end_headers () def do_POST ( self ): logging . info ( self . path ) if m := re . match ( self . updatenamepattern , self . path ): file_length = int ( self . headers . get ( \"Content-Length\" , - 1 )) try : keyvalues = parse_qs ( self . rfile . read ( file_length ), max_num_fields = 2 ) # encoding is assumed to be UTF-8 except ValueError : self . send_response_only ( HTTPStatus . BAD_REQUEST ) self . end_headers () return stationid = keyvalues . get ( b \"id\" , [ b \"\" ])[ 0 ] . decode ( \"UTF-8\" ) name = keyvalues . get ( b \"name\" , [ b \"\" ])[ 0 ] . decode ( \"UTF-8\" ) if stationid == \"\" or name == \"\" : self . send_response_only ( HTTPStatus . BAD_REQUEST ) self . end_headers () return names = db . names ( stationid , name ) # TODO refactor duplicate code names = \" \\n \" . join ( f '<tr><td> { s } </td><td> { n } </td><td><a href=\"/static/updatename.html?id= { quote ( s ) } &name= { quote ( n ) } \">Change</a></td></tr>' for s , n in names . items () ) self . send_response ( HTTPStatus . OK ) html = f \"\"\"<html><body> <table> { names } </table> </body></html> \"\"\" self . send_header ( \"Content-type\" , \"text/html\" ) self . send_header ( \"Content-Length\" , str ( len ( html ))) self . common_headers () self . end_headers () self . wfile . write ( bytes ( html , \"UTF-8\" )) return return InterceptorHandler class Interceptor ( HTTPServer ): DOCS allow_reuse_address = True def __init__ ( self , server_address , db , static_directory ): super () . __init__ ( server_address , InterceptorHandlerFactory . getHandler ( db , static_directory ) )","title":"htcollector.Server"},{"location":"apidoc/source/htcollector.Utils/","text":"SOURCE CODE htcollector. Utils DOCS # shellyhtcollector, a python module to process sensor readings from Shelly H&T devices # # (C) 2022 Michel Anders (varkenvarken) # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; either version 2 of the License, or # (at your option) any later version. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # GNU General Public License for more details. # # You should have received a copy of the GNU General Public License # along with this program; if not, write to the Free Software # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, # MA 02110-1301, USA. # # version: 20220805094810 import json from datetime import datetime , timedelta class DatetimeEncoder ( json . JSONEncoder ): DOCS def default ( self , obj ): DOCS if isinstance ( obj , datetime ): return obj . isoformat () if isinstance ( obj , timedelta ): return str ( obj ) # Let the base class default method raise the TypeError return json . JSONEncoder . default ( self , obj )","title":"htcollector.Utils"},{"location":"apidoc/source/htcollector/","text":"SOURCE CODE htcollector DOCS # shellyhtcollector, a python module to process sensor readings from Shelly H&T devices # # (C) 2022 Michel Anders (varkenvarken) # # This program is free software; you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation; either version 2 of the License, or # (at your option) any later version. # # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # GNU General Public License for more details. # # You should have received a copy of the GNU General Public License # along with this program; if not, write to the Free Software # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, # MA 02110-1301, USA. # # version: 20220806152902 # pylnlib : a package to communicate with a model railroad controller using the LocoNet\u00ae protocol # # (c) 2022 Michel Anders (varkenvarken) # # License: GPL 3, see file LICENSE # # Version: 20220806152902 \"\"\" This package can be invoked as a module. Example: ```bash nohup python -m shellyhtcollector -p 1883 & ``` If invoked this way, it will start listening for data on port 1883. For more info run it with the -- help option ```bash python -m shellyhtcollector --help ``` \"\"\"","title":"htcollector"}]}